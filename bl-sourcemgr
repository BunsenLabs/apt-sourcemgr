#!/usr/bin/env python3

from argparse import (ArgumentParser, ArgumentDefaultsHelpFormatter, ArgumentError)
from aptsources import sourceslist
import sys
import os
import re

def get_options():
    ap = ArgumentParser(description="""CLI for managing local APT sources.list configuration""",
            formatter_class=ArgumentDefaultsHelpFormatter)

    ap.add_argument("verb",
            choices=["add","remove","enable","disable","find"],
            help="""
Action the program takes.

add - Ensure that a sources.list entry conforming to the specification
is present.

remove - Remove all sources.list entries matching the filter
specification. If any matching entry resides in a file with other
entries, the entry won't get removed but disabled instead.

enable - Find existing entries matching the filter specification, and
ensure they're enabled (not commented out).

disable - Find existing entries matching the filter specification, and
ensure they're disabled (commented out).
""")
    ap.add_argument("-F", "--file",
            default=None,
            help="""
Path to the .list file to store the entry in. Works only with the `add`
verb. Note that if a similar entry already exists (for example when just
adding a component), or if the entry is present but disabled), the
existing entry will be reused, modified and the file argument will be
ignored.""")
    ap.add_argument("-D", "--disabled",
            action="store_true",
            default=None,
            help="""
Matches disabled (commented-out) entries.
""")
    ap.add_argument("-E", "--enabled",
            action="store_true",
            default=None,
            help="""
Matches enabled (not commented-out) entries.
""")
    ap.add_argument("-I", "--invalid",
            action="store_true",
            default=None,
            help="""
Matches invalid entries.
""")
    ap.add_argument("-a", "--architecture",
            action="append",
            default=None,
            help="""
Matches entries with the given architecture(s). May be specified
multiple times.
""")
    ap.add_argument("-c", "--component",
            action="append",
            default=None,
            help="""
Matches entries with the given component(s). May be specified multiple
times.
""")
    ap.add_argument("-d", "--distribution",
            default=None,
            help="""
Matches the given distribution.
""")
    ap.add_argument("-f", "--fuzzy",
            default=False,
            action="store_true",
            help="""
Normally, whenever a list-based filter parameter is being evaluated,
entries only match if they fulfill the specification completely. For
example, when filtering using `--component main`, entries which possess
the component `main` but also `contrib` will not match.

By setting this flag, entries will match if *any* of the command line
filter paramters will match.

Applies only to: --architecture, --component.
""")
    ap.add_argument("-r", "--regex-uri-and-distro",
            default=False,
            action="store_true",
            help="""
When used with the `find` action, --uri and --distribution will now be
evaluated as case-insensitive regular expressions against the entry.
""")
    ap.add_argument("-t", "--type",
            default=None,
            choices=["deb","deb-src"],
            help="""
Source type.
""")
    ap.add_argument("-u", "--uri",
            default=None,
            help="""
Source URI.
""")
    ap.add_argument("-s", "--simulate",
            action="store_true",
            default=False,
            help="""
Do not save any changes. Implies --verbose.
""")
    ap.add_argument("-v", "--verbose",
            action="store_true",
            default=False,
            help="""
Log program actions to stderr.
""")

    return ap.parse_args()


def find_entries(entries, opts):
    """Find source entries matching the specification"""

    def cmp_list(x, y):
        if y is None:
            return True

        if opts.fuzzy:
            return any([ x.count(yy) > 0 for yy in y ])

        return set(x) == set(y)

    def cmp_uri(x, y):
        if y is None:
            return True

        if opts.regex_uri:
            r = re.compile(y, flags=re.IGNORECASE)
            return r.search(x)

        return x == y

    def cmp_other(x, y):
        if y is None:
            return True
        return x == y

    def _filter(e):
        return (cmp_list(e.architectures, opts.architecture) and
                cmp_list(e.comps, opts.component) and
                cmp_uri(e.uri, opts.uri) and
                cmp_other(e.dist, opts.distribution) and
                cmp_other(not e.disabled, opts.enabled) and
                cmp_other(e.disabled, opts.disabled) and
                cmp_other(e.invalid, opts.invalid) and
                cmp_other(e.type, opts.type))

    return filter(_filter, entries)

def main():
    opts = get_options()
    deletion_queue = []

    try:
        src = sourceslist.SourcesList()

        if opts.verb == "add":
            kwargs = dict()
            if opts.file is not None:
                kwargs["file"] = opts.file
            src.add(opts.type, opts.uri, opts.distribution, opts.component, **kwargs)
        else:
            entries = find_entries(src.list, opts)
            if opts.verb == "find":
                for e in entries:
                    print(e)
            elif opts.verb == "remove":
                for e in entries:
                    if all([ x is not e and x.file != e.file for x in src.list ]):
                        deletion_queue.append(e.file)
                        src.remove(e)
                    else:
                        print("Entry has other neighbours, disabling instead of removing: <{}>".format(e))
                        e.set_enabled(False)
            elif opts.verb == "enable":
                for e in entries:
                    e.set_enabled(True)
            elif opts.verb == "disable":
                for e in entries:
                    e.set_enabled(False)

        if not opts.simulate and opts.verb != "find":
            src.save()
            for path in deletion_queue:
                print("Would delete", path)
                #os.remove(path)
    except BaseException as e:
        print("ERROR, will not save any change(s):", e)
        return 1

    return 0

if __name__ == "__main__":
    sys.exit(main())

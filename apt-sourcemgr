#!/usr/bin/env python3

# apt-sourcemgr - CLI around python-apt for simple APT sources.list entry management
# Copyright (C) 2018 Jens John <dev ! 2ion ! de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from aptsources import sourceslist, distinfo
from argparse import (ArgumentParser, ArgumentDefaultsHelpFormatter, ArgumentError)
import os
import re
import sys

EXIT_SUCCESS, EXIT_FAILURE, EXIT_NOMATCH = 0, 1, 2

def get_options():
    ap = ArgumentParser(description="""CLI for managing local APT sources.list configuration""",
            formatter_class=ArgumentDefaultsHelpFormatter)

    ap.add_argument("verb",
            choices=["add","remove","enable","disable","find","apply-template"],
            help="""
Action the program takes. If there is an error, the program will exit
with EXIT_FAILURE (see below for numeric exit codes).

add - Ensure that a sources.list entry conforming to the specification
is present.

apply-template - Ensures that all sources.list entries mandated by the
given APT template are present and enabled. Use --template to pass in
the template name.

disable - Find existing entries matching the filter specification, and
ensure they're disabled (commented out).

enable - Find existing entries matching the filter specification, and
ensure they're enabled (not commented out).

find - Print all sources.list entries matching the filter specification
to stdout. If no match is found and there was no general error, exists
with EXIT_NOMATCH.

remove - Remove all sources.list entries matching the filter
specification. If any matching entry resides in a file with other
entries, the entry won't get removed but disabled instead.


EXIT STATUS CODES: 0 - no error (EXIT_SUCCESS), 1 - general faillure
(EXIT_FAILURE), 2 - no match (EXIT_NOMATCH).
""")
    ap.add_argument("-F", "--file",
            default=None,
            help="""
Path to the .list file to store the entry in. Works only with the `add`
verb. Note that if a similar entry already exists (for example when just
adding a component), or if the entry is present but disabled), the
existing entry will be reused, modified and the file argument will be
ignored.""")
    ap.add_argument("-D", "--disabled",
            action="store_true",
            default=None,
            help="""
Matches disabled (commented-out) entries.
""")
    ap.add_argument("-E", "--enabled",
            action="store_true",
            default=None,
            help="""
Matches enabled (not commented-out) entries.
""")
    ap.add_argument("-I", "--invalid",
            action="store_true",
            default=None,
            help="""
Matches invalid entries.
""")
    ap.add_argument("-a", "--architecture",
            action="append",
            default=None,
            help="""
Matches entries with the given architecture(s). May be specified
multiple times.
""")
    ap.add_argument("-c", "--component",
            action="append",
            default=None,
            help="""
Matches entries with the given component(s). May be specified multiple
times.
""")
    ap.add_argument("-d", "--distribution",
            default=None,
            help="""
Matches the given distribution.
""")
    ap.add_argument("-f", "--fuzzy",
            default=False,
            action="store_true",
            help="""
Normally, whenever a list-based filter parameter is being evaluated,
entries only match if they fulfill the specification completely. For
example, when filtering using `--component main`, entries which possess
the component `main` but also `contrib` will not match.

By setting this flag, entries will match if *any* of the command line
filter paramters will match.

Applies only to: --architecture, --component.
""")
    ap.add_argument("-r", "--regex",
            default=False,
            action="store_true",
            help="""
When used with the `find` action, --uri and --distribution will now be
evaluated as case-insensitive regular expressions against the entry.
""")
    ap.add_argument("-t", "--type",
            default=None,
            choices=["deb","deb-src"],
            help="""
Source type.
""")
    ap.add_argument("-u", "--uri",
            default=None,
            help="""
Source URI.
""")
    ap.add_argument("-s", "--simulate",
            action="store_true",
            default=False,
            help="""
Do not save any changes. Implies --verbose.
""")
    ap.add_argument("-v", "--verbose",
            action="store_true",
            default=False,
            help="""
Log program actions to stderr.
""")
    ap.add_argument("-T", "--template",
            default=None,
            type=str,
            help="""
Derive all specifications from the given pyton-apt template. Only used
by the apply-template action.
""")

    return ap.parse_args()


def find_entries(entries, opts):
    """Find source entries matching the specification"""

    def cmp_list(x, y):
        if y is None:
            return True

        if opts.fuzzy:
            return any([ x.count(yy) > 0 for yy in y ])

        return set(x) == set(y)

    def cmp_regex(x, y):
        if y is None:
            return True

        if opts.regex:
            return not not re.search(y, x, flags=re.IGNORECASE)

        return x == y

    def cmp_other(x, y):
        if y is None:
            return True
        return x == y

    def _filter(e):
        return (cmp_list(e.architectures, opts.architecture) and
                cmp_list(e.comps, opts.component) and
                cmp_regex(e.uri, opts.uri) and
                cmp_regex(e.dist, opts.distribution) and
                cmp_other(not e.disabled, opts.enabled) and
                cmp_other(e.disabled, opts.disabled) and
                cmp_other(e.invalid, opts.invalid) and
                cmp_other(e.type, opts.type))

    return filter(_filter, entries)

def main():
    opts = get_options()

    if opts.verb != "find" and (not opts.simulate and os.geteuid() > 0):
        print("Error: The given action requires root privileges.",
                file=sys.stderr)
        return EXIT_FAILURE

    if (opts.verb == "apply-template" and (opts.template is None or
        opts.distribution is None)):
        print("Error: `apply-template` requires non-empty --template and --distribution paramters.",
                file=sys.stderr)
        return EXIT_FAILURE

    try:
        deletion_queue = []
        src = sourceslist.SourcesList()

        if opts.verb == "add":
            kwargs = dict()
            if opts.file is not None:
                kwargs["file"] = opts.file
            if not all([opts.type, opts.uri, opts.distribution,
                opts.component]):
                raise BaseException("Not enough arguments: add")
            src.add(opts.type, opts.uri, opts.distribution, opts.component, **kwargs)

        elif opts.verb == "apply-template":
            def match_distro(v):
                if opts.regex:
                    return not not re.search(opts.distribution, v, flags=re.IGNORECASE)
                else:
                    return v == opts.distribution
            di = distinfo.DistInfo(dist=opts.template)
            # TODO: Implement mirror selection.
            for t in filter(lambda t: match_distro(t.name), di.templates):
                base_uri = t.base_uri if t.base_uri is not None else t.parents[0].base_uri
                base_components = [ c.name for c in (t.components if
                    len(t.components)>0 else t.parents[0].components) ]
                if opts.component is not None:
                    base_components = list(filter(lambda c: c in opts.component,
                        base_components))
                    if len(base_components) == 0:
                        print("Error: No components left for template after filtering.", file=sys.stderr)
                        return EXIT_FAILURE
                src.add(t.type, base_uri, t.name, base_components)
        else:
            entries = list(find_entries(src.list, opts))
            if len(entries) == 0:
                return EXIT_NOMATCH

            if opts.verb == "find":
                for e in entries:
                    print(e)

            elif opts.verb == "remove":
                for e in entries:
                    if all([ x is not e and x.file != e.file for x in src.list ]):
                        deletion_queue.append(e.file)
                        src.remove(e)
                    else:
                        print("Entry has other neighbours, disabling instead of removing: <{}>".format(e),
                                file=sys.stderr)
                        e.set_enabled(False)

            elif opts.verb == "enable":
                for e in entries:
                    e.set_enabled(True)

            elif opts.verb == "disable":
                for e in entries:
                    e.set_enabled(False)

        if not opts.simulate and opts.verb != "find":
            src.save()
            for path in deletion_queue:
                os.remove(path)
    except BaseException as e:
        print("ERROR, will not save any change(s):", e, file=sys.stderr)
        return EXIT_FAILURE

    return EXIT_SUCCESS

if __name__ == "__main__":
    sys.exit(main())
